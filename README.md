# Setup monorepo and release

This project serves as a test for setting up a monorepo with automatic changelog and release generation upon merges into the main branch. Refer to the usage section to determine if this configuration meets your needs.

## Stack

- `NodeJS` & `NPM`
- Monorepo with `Lerna`
- Version control with `Git` / `Github`
- Conventionals Commit with `commitizen`
- Commit lint with `husky` and `commitlint`

## Project Structure

```
  root
    │
    ├── .husky
    │       ├── commit-msg
    │       └── pre-commit
    │
    ├── .github
    │       └── workflows
    │              └── release.yml
    │
    ├── packages
    │       ├── package1
    │       │       ├── package1
    │       │       └── package2
    │       └── package2
    │               ├── package1
    │               └── package2
    │
    ├── commitlint.config.json
    ├── lerna.json
    └── package.json
```

## Setup

### Configure Lerna

Install Lerna

```shell
npm intall -D Lerna
```

Configure Lerna to use workspaces in `package.json`

```json
"workspaces": [
    "packages/*"
]
```

You should run `npm install` command to actually set the workspace.

Initialize Lerna.

```shell
npx lerna init
```

Tell Lerna to use `independent` versions by modifying `lerna.json`.  
We also add a custom message for releases.

```json
{
  "version": "independent",
  "npmClient": "npm",
  "command": {
    "publish": {
      "conventionalCommits": true,
      "message": "chore(release): publish"
    }
  }
}
```

### Setup Conventional Commits

We first install `commitizen` as commit formater helper.

```shell
npm install -D commitizen cz-conventional-changelog
```

Then we configure `package.json` on root to use `Commitizen`.

```json
"config": {
  "commitizen": {
    "path": "./node_modules/cz-conventional-changelog"
  }
}
```

Now we need to create a `commitlint.config.js` file to root.

```javascript
export default {
  extends: ["@commitlint/config-conventional"],
};
```

### Setup Commit Lint

First install husky

```shell
npm install -D husky
```

Initialize husky

```shell
npx husky init
```

Create a `.husky/commit-msg` file.

```
#!/usr/bin/env sh
npx --no -- commitlint --edit $1
```

### Automate realease with Github Action

Create a `.github/workflows/release.yml` file.

```yaml
name: Lerna Release

on:
  push:
    branches:
      - main

jobs:
  release:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v2
        with:
          fetch-depth: 0 # Important for commit history analysis
      - uses: actions/setup-node@v2
        with:
          node-version: "20"
      - name: Install Dependencies
        run: npm install
      - name: Lerna Version and Publish
        run: |
          git config --global user.email "you@example.com"
          git config --global user.name "Your Name"
          npx lerna version --yes --conventional-commits --create-release github --no-push
          npx lerna publish from-git --yes
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          NODE_AUTH_TOKEN: ${{ secrets.NPM_TOKEN }}
```

`GITHUB_TOKEN` and `NPM_TOKEN` should be saved in your Github secrets.

## Usage

1. Create a new branch for your current task (feat, fix, doc...)
2. Create commits usings `commitizen`
3. Create a pull request when your done for a merge on `main`
4. When the PR is approved the workflow will run:
   - `Lerna` will versionize and publish packages using conventionals commit
   - A Github Release will be created with the changelog generated by `Lerna`
